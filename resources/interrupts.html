<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My stuff | Eievui</title>
    <link rel="icon" href="../favicon.ico">
    <link rel="stylesheet" href="../style.css">
    <style>
        code {
            color: rgb(29, 163, 85);
            font-size: large;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <header><iframe class="header" src="../header.html"></iframe></header>
    <h1 style="text-align: center;">Interrupts</h1>

    <p>
        This guide assumes you have a short project to test code on. ISSOtm's
        "Hello World!" tutorial should work fine as a base.
    </p>

    <p>
        Interrupts are used to call a given function when certain conditions are
        met. On the Game Boy, these conditions are:
        <ul>
            <li>The beginning of the VBlank period</li>
            <li>A Joypad input</li>
            <li>A serial data transfer from the link cable</li>
            <li>The tick of a configurable timer</li>
            <li>A configurable LCD Status interrupt</li>
        </ul>
        For the purposes of this short guide we will focus on the most prevalent
        interrupt - VBlank
    </p>

    <h2>VBlank</h2>

    <p>
        VBlank refers to the period of time that the screen spends returning to
        the upper-left hand corner, and during this time the PPU gives the CPU
        access to VRAM. Because of this, most VRAM access during normal gameplay
        must occur during VBlank.
    </p>

    <p>
        But how do you know when VBlank has started? If you have read ISSOtm's
        gb-asm-tutorial you likely know how to use a loop for this, which checks the
        value of <code>rLY</code> to see if it is past the screen area. However, because
        this loop must continually run to check for VBlank, you may miss VBlank
        entirely or enter your VBlank code too late. Additionally, loops like
        that keep the CPU running, wasting power on real hardware. This isn't an
        issue for turning off the screen, but when you have time-sensitive code
        and a loop running game logic, it's important to make sure everything is
        run at predictable intervals.
    </p>

    <p>
        This is where the VBlank interrupt comes in. When the VBlank period
        starts a flag will be set that tells the CPU to stop what it's doing,
        and call the address <code>$0040</code>.
    </p>

    <p>
        Before we even enable interrupts, let's write some VBlank code...
    </p>

    <code>
        ; Define a new section and hard-code it to be at $0040.<br>
        SECTION "VBlank Interrupt", ROM0[$0040]<br>
        VBlankInterrupt:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; This instruction is equivalent to <code>ret</code> and <code>ei</code><br>
        &nbsp;&nbsp;&nbsp;&nbsp;reti
    </code>

    <p>
        That handler doesn't do anything yet, but without it our VBlank
        interrupt would jump to <code>$0040</code> and begin running random code, either
        the header or a portion of your ROM. Additionally, when an interrupt is
        fired it automatically runs <code>di</code>, which disables interrupts so that
        nothing else conflicts with the handler. <code>reti</code> is the same as an <code>ei</code>
        followed by a <code>ret</code>, so the interrupted code can continue executing and
        VBlank can be fired the next time it's needed.
    </p>

    <h2>Configuring an interrupt</h2>

    <p>
        Make sure you have a copy of 'hardware.inc', we're going to use it quite
        a bit here.
    </p>

    <p>
        To enable the VBlank interrupt we need to write to the
        <a href="https://gbdev.io/pandocs/#ffff-ie-interrupt-enable-r-w">Interrupt Enable register</a>,
        <code>rIE</code>. If you take a look at <code>rIE</code> on the Pandocs, you can see what
        interrupt each bit corresonds to, but we're going to focus on VBlank's
        bit, bit 0. To enable the VBlank interrupt, all we need to do is set bit
        0 of <code>rIE</code> to 1, so let's do that!
    </p>

    <code>
        SECTION "Init", ROM0<br>
        Init:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; Place the following somewhere in your initiallization code:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; hardware.inc defines a handy flag that we can use.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ld a, IEF_VBLANK<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ldh [rIE], a<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; ...
    </code>

    <p>
        Additionally, we should clear another register while we're at it, <code>rIF</code>.
        <code>rIF</code> is used by the CPU to begin an interrupt; basically, if any of
        the bits in <code>rIF</code> and <code>rIE</code> match, the corresponding inturrupt is
        called. However, <code>rIF</code> may have leftover values that would accidentally
        set off an interrupt at the wrong time, so we need to manually clear it.
    </p>

    <code>
        &nbsp;&nbsp;&nbsp;&nbsp;xor a, a ; This is equivalent to <code>ld a, 0</code>!<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ldh [rIF], a
    </code>

    <p>
        Finally! Now the last step is running the instuction <code>ei</code>, which
        globally enables interrupts. This is *not* the same as <code>rIE</code>.
    </p>

    <code>
        &nbsp;&nbsp;&nbsp;&nbsp;ei
    </code>

    <p>
        If you run your rom now... you'll notice no difference. That's because
        our VBlank code doesn't do anything yet. But we can make it do something
        with just one instruction: <code>halt</code>.
    </p>

    <p>
        Your program likely has a loop somewhere which either does nothing, or
        continually runs some logic:
    </p>

    <code>
        .endlessLoop<br>
        &nbsp;&nbsp;&nbsp;&nbsp;jr .endlessLoop
    </code>

    <p>
    But this keeps the CPU running forever! Instead, we should give it a rest
    using the <code>halt</code> instruction. Just place <code>halt</code> at the end of that loop...
    </p>

    <code>
        .endlessLoop<br>
        &nbsp;&nbsp;&nbsp;&nbsp;halt<br>
        &nbsp;&nbsp;&nbsp;&nbsp;jr .endlessLoop
    </code>

    <p>
    ... and run your program! If you're using BGB or Emulicious, you can check
    the Game Boy's CPU usage in their debuggers. Open it up and compare the
    meter with and without halt. You should see nearly *0%* usage when halt is
    being used, because only three instructions are run per frame now.
    </p>

    <h2>Taking advantage of VBlank</h2>

    <p>
        Okay, saving power is great, but how does this help you write a Game Boy
        game? Well since the interrupt occurs as soon as VBlank starts, it gives
        us the perfect opportunity to access VRAM and graphics-related registers.
        We can start by playing with palettes. First, define a variable in HRAM;
        we'll use this as a frame counter.
    </p>

    <code>
        SECTION "Frame Counter", HRAM<br>
        hFrameCounter:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;db
    </code>

    <p>
    Now, go back to that loop from earlier. Right before <code>halt</code>, add some code
    to increment <code>hFrameCounter</code>.
    </p>

    <code>
        .endlessLoop<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; Make sure to use <code>ldh</code> for HRAM and registers, and not a regular <code>ld</code><br>
        &nbsp;&nbsp;&nbsp;&nbsp;ldh a, [hFrameCounter]<br>
        &nbsp;&nbsp;&nbsp;&nbsp;inc a<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ldh [hFrameCounter], a<br>
        &nbsp;&nbsp;&nbsp;&nbsp;halt<br>
        &nbsp;&nbsp;&nbsp;&nbsp;jr .endlessLoop
    </code>

    <p>
        Now, right before the loop halts, it'll increment a little timer which
        we can use for delays. We're going to use that timer to flicker the
        palettes back and forth in a short cycle during VBlank.
    </p>

    <p>
        However, there is *one* issue to take care of: we only have 8 bytes of
        space in the VBlank interrupt handler! This is fine though, just jump
        outiside of the handler and continue execution. And while we're at it,
        we're going to <code>push</code> every register, including the flags, to the stack.
        This is because there's a good chance VBlank will occur before the loop
        gets back to <code>halt</code> in a real game, and we don't want to ruin any
        registers that the game was relying on.
    </p>

    <code>
        SECTION "VBlank Interrupt", ROM0[$0040]<br>
        VBlankInterrupt:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;push af<br>
        &nbsp;&nbsp;&nbsp;&nbsp;push bc<br>
        &nbsp;&nbsp;&nbsp;&nbsp;push de<br>
        &nbsp;&nbsp;&nbsp;&nbsp;push hl<br>
        &nbsp;&nbsp;&nbsp;&nbsp;jp VBlankHandler<br>
<br>
        SECTION "VBlank Handler", ROM0<br>
        VBlankHandler:<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; Now we just have to <code>pop</code> those registers and return!<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pop hl<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pop de<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pop bc<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pop af<br>
        &nbsp;&nbsp;&nbsp;&nbsp;reti
    </code>

    <p>
        Perfect! Now let's write some code. I'll heavily comment this to help
        you follow:
    </p>

    <code>
        SECTION "VBlank Handler", ROM0<br>
        VBlankHandler:<br>
<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; Begin by loading the frame counter<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ldh a, [hFrameCounter]<br>
<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; Now check the 5th bit, causing it to set the zero flag for 32 frames,<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; every 32 frames. (about half a second on and off)<br>
        &nbsp;&nbsp;&nbsp;&nbsp;bit 5, a<br>
<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; Now we're going to load a standard palette into <code>a</code>, but if the zero<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; flag is set we'll complement it, inverting every color.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ld a, %11100100<br>
<br>
        &nbsp;&nbsp;&nbsp;&nbsp;jr z, .skipCpl<br>
        &nbsp;&nbsp;&nbsp;&nbsp;cpl ; ComPleMent <code>a</code>. Flips every bit in <code>a</code><br>
        .skipCpl<br>
<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; Finally, load <code>a</code> into <code>rBGP</code>, the Game Boy's Background Palette register.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;ldh [rBGP], a<br>
<br>
<br>
        &nbsp;&nbsp;&nbsp;&nbsp;; Now we just have to <code>pop</code> those registers and return!<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pop hl<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pop de<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pop bc<br>
        &nbsp;&nbsp;&nbsp;&nbsp;pop af<br>
        &nbsp;&nbsp;&nbsp;&nbsp;reti
    </code>

    <p>
        Now you should see the colors invert every 32 frames.
    </p>

    <p>
        If you're looking for something else to try on your own, try writing to
        a different tile each VBlank to slowly fill up the screen with a custom
        tile. Or load different graphics during VBlank to animate an existing
        tile!
    </p>
</body>